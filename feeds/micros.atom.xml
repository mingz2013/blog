<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mingz's Blog - micros</title><link href="http://mingz.me/blog/" rel="alternate"></link><link href="http://mingz.me/blog/feeds/micros.atom.xml" rel="self"></link><id>http://mingz.me/blog/</id><updated>2019-05-23T12:00:00+02:00</updated><entry><title>DevOps</title><link href="http://mingz.me/blog/posts/2019/May/23/devops/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/devops/</id><summary type="html">&lt;p&gt;devops&lt;/p&gt;</summary><content type="html">&lt;h1&gt;DevOps&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps（Development &amp;amp; Operations）即开发运维一体化，可理解为软件研发的一种过程，方法，文化，运动或实践，主要是通过一条高度自动化的流水线来加强开发，测试，运维和其他部门之间的沟通和协作，加速产品和服务的交付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="DevOps流程图" src="./images/devops-01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="DevOps流水线" src="./images/devops-02.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="DevOps工具链" src="./images/devops-03.png"&gt;&lt;/p&gt;</content><category term="devops"></category><category term="micro service"></category></entry><entry><title>Docker</title><link href="http://mingz.me/blog/posts/2019/May/23/docker/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/docker/</id><summary type="html">&lt;p&gt;docker&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Docker&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;h3&gt;Container&lt;/h3&gt;
&lt;p&gt;&lt;img alt="容器和虚拟机对比" src="./images/containers-01.png"&gt;&lt;/p&gt;
&lt;h3&gt;Docker&lt;/h3&gt;
&lt;p&gt;事实上的标准&lt;/p&gt;
&lt;p&gt;docker，优势，可以构建一个隔离的，稳定的，安全地，高性能的容器运行环境。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker help&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;docker-compose&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker-compose help&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/mingz2013/demo-todos-go-micro&lt;/li&gt;
&lt;li&gt;https://github.com/mingz2013/demo-todos-vue&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;演示&lt;/h3&gt;
&lt;p&gt;本地演示用docker-compose实现单机部署，实现进程scale。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/docker&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WebSite&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://www.docker.com/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Books&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《Docker技术入门与实战（第3版）》&lt;/li&gt;
&lt;/ul&gt;</content><category term="docker"></category><category term="micro service"></category></entry><entry><title>go-micro</title><link href="http://mingz.me/blog/posts/2019/May/23/go-micro/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/go-micro/</id><summary type="html">&lt;p&gt;go-micro&lt;/p&gt;</summary><content type="html">&lt;h1&gt;go-micro&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Micro是一套微服务构建工具库。对于微服务架构的应用，Micro提供平台层面、高度弹性的工具组件，让服务开发者们可以把复杂的分布式系统以简单的方式构建起来，并且尽可能让开发者使用最少的时间完成基础架构的构建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网关&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web Dashboard&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务发现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;同步通信&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;li&gt;消息编码&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务接口-Golang开发框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件可插拔&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;h3&gt;架构&lt;/h3&gt;
&lt;p&gt;&lt;img alt="go micro todos" src="./images/go-micro-01.png"&gt;&lt;/p&gt;
&lt;h3&gt;演示&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/micro&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WebSite&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://micro.mu/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;https://micro.mu/docs/cn/index.html&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="go-micro"></category><category term="micro service"></category></entry><entry><title>istio</title><link href="http://mingz.me/blog/posts/2019/May/23/istio/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/istio/</id><summary type="html">&lt;p&gt;istio&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Istio&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;h3&gt;Service Mesh&lt;/h3&gt;
&lt;p&gt;要讨论服务网格（Service Mesh），就必须提到微服务（Microservices）。&lt;/p&gt;
&lt;p&gt;为了解决微服务架构产生的一些问题，以k8s为代表的容器云系统出现了。这类容器云系统以容器技术为基础，在进程级别为微服务提供了一致的部署，调度，伸缩，监控，日志等功能。&lt;/p&gt;
&lt;p&gt;然而，除了进程本身的问题，微服务之间的通信和联系更加复杂，其中的观测，控制和服务质量等都成为微服务方案的短板，因此随着k8s成为事实标准，Service mesh顺势登场。&lt;/p&gt;
&lt;p&gt;自Service Mesh技术诞生以来，国内外出现了很多产品，下面选择其中几个重要的产品和事件，大概理理Service Mesh相关产品的发展情况。&lt;/p&gt;
&lt;p&gt;Buoyant公司的CEO William，曾经给出对服务网格的定义：服务网格是一个独立的基础设施层，用来处理服务之间的通信。&lt;/p&gt;
&lt;p&gt;现代的云原生应用是由各种复杂技术构建的服务组成的，服务网格负责在这些组成部分之间进行可靠的请求传递。&lt;/p&gt;
&lt;p&gt;目前典型的服务网格通常提供了一组轻量级的网络代理，这些代理会在应用无感知的情况下，同应用并行部署，运行。&lt;/p&gt;
&lt;p&gt;Service Mesh主要功能：
1. 负载均衡
2. 服务发现
3. 熔断
4. 动态路由
5. 安全通信
6. 多语言支持
7. 多协议支持
8. 指标和分布式追踪
9. 重试和最后期限&lt;/p&gt;
&lt;p&gt;总结一下，Service Mesh实现了四大关键功能：
1. 实现对基础设施的抽象化
2. 为应用请求提供可靠传递
3. 每个业务节点部署轻量级代理
4. 透明化，应用程序无感知。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./images/network-01.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;Service Mesh类似于更高级的一层网络栈。&lt;/p&gt;
&lt;p&gt;k8s就是微服务级别的操作系统。&lt;/p&gt;
&lt;p&gt;Helm是k8s的包管理工具，类似于yum，apt-get。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Servie Mesh网络架构" src="./images/servicemesh-01.png"&gt;&lt;/p&gt;
&lt;h4&gt;Sidecar&lt;/h4&gt;
&lt;p&gt;&lt;img alt="" src="./images/sidecar-01.jpeg"&gt;&lt;/p&gt;
&lt;h3&gt;Istio&lt;/h3&gt;
&lt;p&gt;事实上的标准&lt;/p&gt;
&lt;p&gt;2017年5月，Google，IBM和Lyft宣布了Istio的诞生。Istio以Envoy为数据平面，通过Sidecar的方式让Envoy同业务容器一起运行，并劫持其通信，接受控制平面的统一管理，在此基础上为服务之间的通信提供了丰富的连接，控制，观察，安全等特性。&lt;/p&gt;
&lt;p&gt;Istio一经发布，便立刻获得Red Hat，F5等大牌厂商的响应，虽然立足不稳，但各个合作方都展示了对社区，行业的强大影响力。于是，Istio很快就超越了Linkerd，成为Service Mesh的代表产品。&lt;/p&gt;
&lt;p&gt;这里将Istio的特性总结如下。
- 连接：对网格内部的服务之间的调用所产生的流量进行智能管理，并以此为基础，为微服务的部署，测试和升级等操作提供有力保障。
- 安全：为网络内部的服务之间的调用提供认证，加密和鉴权支持，在不侵入代码的情况下，加固现有服务，提高其安全性。
- 策略：在控制面定制策略，并在服务中实施
- 观察：对服务之间的调用进行跟踪和测量，获取服务的状态信息。&lt;/p&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/istio&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WebSite&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://istio.io/&lt;/li&gt;
&lt;li&gt;https://istio.io/zh/docs/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Books&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《深入浅出Istio：Service Mesh快速入门与实践》&lt;/li&gt;
&lt;/ul&gt;</content><category term="istio"></category><category term="micro service"></category></entry><entry><title>k8s</title><link href="http://mingz.me/blog/posts/2019/May/23/k8s/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/k8s/</id><summary type="html">&lt;p&gt;k8s&lt;/p&gt;</summary><content type="html">&lt;h1&gt;kubernetes&lt;/h1&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;p&gt;k8s业已称为容器编排领域事实上的标准&lt;/p&gt;
&lt;p&gt;还要考虑集群管理，高可用，安全，持续集成等方方面面的问题。
这些关于容器集群管理的问题，其实就是容器编排的问题，即Kubernetes要解决的问题。
OpenShift集成了原生的Kubernetes作为容器编排组件。OpenShift通过Kubernetes来管理容器集群中的机器节点及容器，为业务应用提供：
- 容器调度
- 弹性伸缩
- 异常自愈
- 持久化卷
- 服务发现
- 配置管理&lt;/p&gt;
&lt;p&gt;Kubernetes特性
1. 自动装箱
2. 自我修复
3. 水平扩展
4. 服务发现和负载均衡
5. 自动发布和回滚
6. 密钥和配置管理
7. 存储编排
8. 批量处理执行&lt;/p&gt;
&lt;p&gt;&lt;img alt="Kubernetes架构" src="./images/k8s-01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="k8s-02.png" src="./images/k8s-02.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="k8s-03.png" src="./images/k8s-03.png"&gt;&lt;/p&gt;
&lt;h3&gt;Helm&lt;/h3&gt;
&lt;p&gt;Kuberneres的安装包管理器，类似于yum，apt-get等
K8s类似于微服务层的操作系统，Helm类似于操作系统上的包管理器。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/kubernetes&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WebSite&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://kubernetes.io/&lt;/li&gt;
&lt;li&gt;https://kubernetes.io/zh/docs/tutorials/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Books&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《每天5分钟玩转Kubernetes》&lt;/li&gt;
&lt;li&gt;《Kubernetes进阶实战》&lt;/li&gt;
&lt;li&gt;《基于Kubernetes的容器云平台实战》&lt;/li&gt;
&lt;/ul&gt;</content><category term="k8s"></category><category term="micro service"></category></entry><entry><title>microservice架构探索</title><link href="http://mingz.me/blog/posts/2019/May/23/micro-index/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/micro-index/</id><summary type="html">&lt;p&gt;micro index&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;禁止转载&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;本目录内文章，图片和文字资源大多来自于网络和参考书籍，如有侵权，请联系删除&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;MicroService架构探索&lt;/h1&gt;
&lt;p&gt;各位领导大家好，今天给大家汇报一下最近的一些关于微服务的研究。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="./microservice.md"&gt;MicroService&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./consul.md"&gt;Consul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./go-micro.md"&gt;go-micro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./spring-cloud.md"&gt;SpringCloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./docker.md"&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./k8s.md"&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./devops.md"&gt;DevOps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./openshift-3.md"&gt;OpenShift 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./serverless.md"&gt;Serverless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./istio.md"&gt;Istio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="./openshift-4.md"&gt;OpenShift 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="micro service"></category></entry><entry><title>microservice</title><link href="http://mingz.me/blog/posts/2019/May/23/microservice/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/microservice/</id><summary type="html">&lt;p&gt;microservice&lt;/p&gt;</summary><content type="html">&lt;h1&gt;MicroService&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务是一种软件架构模式，用来把大而重的应用程序切成许多可管理的、可管理的独立服务，各服务之间的通信并不受不同语言的协议影响，每个服务只管做好一件事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;微服务设计的理念：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;各服务要小 - 单一的业务目标应该是要细粒度，就像Unix的”只做一件事并且要做好”理念。&lt;/li&gt;
&lt;li&gt;组织文化要包含部署与测试的自动化，这个降低管理与操作的负担。&lt;/li&gt;
&lt;li&gt;设计原则要包含失败与错误，就像抗脆弱的系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;为什么要使用微服务&lt;/h3&gt;
&lt;p&gt;随着组织的扩大，使用的技术和员工的数量都在增加，管理单一代码实现的服务，只会变得越来越复杂。&lt;/p&gt;
&lt;h3&gt;微服务特点，如下所述。&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在结构上，将原有的从技术角度拆分的组件，升级为从业务角度拆分的独立运行的服务，这些服务具备各自的实现平台，并且独占自有数据，在服务之间以智能端点和哑管道的方式通信。&lt;/li&gt;
&lt;li&gt;在工程上，从产品而非项目的角度进行设计，强调迭代，自动化和面向故障的设计方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;微服务带来的问题。&lt;/h3&gt;
&lt;p&gt;微服务架构在很大程度上提高了应用的伸缩性，方便了部门或业务之间的协作，使技术岗位能够更好地引入新技术并提高自动化程度，最终达到减耗增效的目的，然而和所有新方法一样，微服务架构在解决老问题的同时，也带来了一些新问题，例如：
- 实例数量急剧增长，对部署和运维的自动化要求更高。
- 用网络调动代替内部API，对网络这一不可靠的基础设施依赖增强
- 调用链路变长，分布式跟踪称为必选项目
- 日志分散严重，跟踪和分析难度加大
- 服务分数，受攻击面积更大
- 在不同的服务之间存在协作关系，需要有更好的跨服务控制协调能力
- 自动伸缩，路由管理，故障控制，存储共享，等等。&lt;/p&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;</content><category term="microservice"></category><category term="micro service"></category></entry><entry><title>openshift 3</title><link href="http://mingz.me/blog/posts/2019/May/23/openshift-3/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/openshift-3/</id><summary type="html">&lt;p&gt;openshift 3&lt;/p&gt;</summary><content type="html">&lt;h1&gt;OpenShift 3&lt;/h1&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;h3&gt;Red Hat&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Red Hat就是开源软件商业模式的奠基人，而且是目前世界上最大的开源软件公司。&lt;/li&gt;
&lt;li&gt;作为一个开源软件公司，red hat所有产品的企业版的源代码也是完全公开的。&lt;/li&gt;
&lt;li&gt;Red Hat是Kubernetes, Istio的主要贡献者之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OpenShift&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OpenShift是一个开源容器云平台，是一个基于主流的容器技术Docker及Kubernetes构建的云平台。&lt;/li&gt;
&lt;li&gt;通过OpenShift这个平台，企业可以快速在内部网络中构建出一个多租户的云平台，在这朵云上提供应用开发，测试，部署，运维的各项服务（如图1-2所示）。&lt;/li&gt;
&lt;li&gt;OpenShift在一个平台上贯通开发，测试，部署，运维的流程，实现高度的自动化，满足应用持续集成及持续交付和部署的需求；满足企业及组织对容器管理，容器编排的需求。&lt;/li&gt;
&lt;li&gt;通过OpenShift的灵活架构，企业可以以OpenShift作为核心，在其上搭建一个企业的DevOps引擎，推动企业的DevOps变革和转型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器引擎及容器编排组件是两项关键的技术，但还不能满足生产效率的要求。
OpenShift在Docker和k8s的基础上提供了各种功能，以满足业务应用，研发用户及运维用户在生产效率上的诉求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用开发框架及中间件&lt;/li&gt;
&lt;li&gt;应用及服务目录&lt;/li&gt;
&lt;li&gt;自动化流程及工具。&lt;/li&gt;
&lt;li&gt;软件自定义网络&lt;/li&gt;
&lt;li&gt;性能监控及日志管理&lt;/li&gt;
&lt;li&gt;多用户接口&lt;/li&gt;
&lt;li&gt;自动化集群部署及管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;K8s是一个容器编排工具，虽然提供了很多的功能，但只是一个工具。而OpenShift是一整套企业解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenShift技术堆栈" src="./images/openshift-3-02.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenShift技术堆栈" src="./images/openshift-3-01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenShift核心组件" src="./images/openshift-3-03.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="OpenShift核心组件及流程" src="./images/openshift-3-04.png"&gt;&lt;/p&gt;
&lt;h3&gt;混合云&lt;/h3&gt;
&lt;h3&gt;DevOps&lt;/h3&gt;
&lt;h3&gt;CI/CD&lt;/h3&gt;
&lt;h2&gt;演示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;演示本地macos的OpenShift单节点集群&lt;/li&gt;
&lt;li&gt;演示OpenShift的Web Dashboard&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/openshift&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WebSite&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;http://www.openshift.org&lt;/li&gt;
&lt;li&gt;https://www.okd.io/&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Books&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《开源容器云OpenShift 构建基于Kubernetes的企业应用云》&lt;/li&gt;
&lt;/ul&gt;</content><category term="openshift 3"></category><category term="micro service"></category></entry><entry><title>openshift 4</title><link href="http://mingz.me/blog/posts/2019/May/23/openshift-4/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/openshift-4/</id><summary type="html">&lt;p&gt;openshift 4&lt;/p&gt;</summary><content type="html">&lt;h1&gt;OpenShift 4&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集成了Istio&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目前处于测试版本状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只提供了Linux上的测试部署方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;h3&gt;WebSite&lt;/h3&gt;
&lt;h3&gt;Books&lt;/h3&gt;</content><category term="openshift 4"></category><category term="micro service"></category></entry><entry><title>Serverless</title><link href="http://mingz.me/blog/posts/2019/May/23/serverless/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/serverless/</id><summary type="html">&lt;p&gt;serverless&lt;/p&gt;</summary><content type="html">&lt;h1&gt;MicroService&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Serverless架构" src="./images/serverless-01.png"&gt;&lt;/p&gt;
&lt;p&gt;Serverless下包含的两个概念：
- 函数即服务，即Function as a Service，简称FaaS
- 后端即服务，即Backend as a Service，简称BaaS。&lt;/p&gt;
&lt;p&gt;目前，Serverless平台主要分为三大类：
1. 公有云上的功能即服务（Functions as a Service，FaaS）解决方案。
2. 运行在共有和私有数据中心的Serverless框架，如Fission运行在Kubernetes上，Funktion运行在Kubernetes上，IBM OpenWhisk运行在Docker上。
3. 提供agnostic应用接口或/和现有Serverless框架增值服务的包装框架，如Serverless.com支持AWS Lambda，Apex支持AWS Lambda。&lt;/p&gt;
&lt;p&gt;Serverless适用场景:
1. 应用负载变化显著的场景
2. 基于事件驱动的算法服务化场景
3. 基于事件驱动的数据分析服务化场景
4. 基于事件驱动的数据服务化场景
5. 低频请求场景&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;</content><category term="serverless"></category><category term="micro service"></category></entry><entry><title>Spring Cloud</title><link href="http://mingz.me/blog/posts/2019/May/23/spring-cloud/" rel="alternate"></link><published>2019-05-23T12:00:00+02:00</published><updated>2019-05-23T12:00:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2019-05-23:/blog/posts/2019/May/23/spring-cloud/</id><summary type="html">&lt;p&gt;spring cloud&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SpringCloud&lt;/h1&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;p&gt;Spring Cloud最早在功能层面为微服务治理定义了一系列标准特性，例如智能路由，熔断机制，服务注册与发现等，并提供了对应的库和组件来实现这些标准特性。到目前为止，这些库和组件被广泛采用。&lt;/p&gt;
&lt;p&gt;Spring Cloud缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;既博采众家之长，也导致了一些散乱的局面，即用户需要学习和熟悉各组件的”方言“并加以运维，这在客观上提高了应用门槛&lt;/li&gt;
&lt;li&gt;需要在代码级别对诸多组件进行控制，包括Sidecar在内的组件都依赖Java的实现，这和微服务的多语言协作目标是背道而驰的&lt;/li&gt;
&lt;li&gt;自身并没有对调度，资源，DevOps等提供相关支持，需要借助其他平台来完成，然而目前的容器编排事实标准是k8s，二者的部分功能存在重合或者冲突，这在一定程度上影响了Spring Cloud的长远发展。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;</content><category term="Spring Cloud"></category><category term="micro service"></category></entry><entry><title>consul 初体验</title><link href="http://mingz.me/blog/posts/2018/Oct/23/consul/" rel="alternate"></link><published>2018-10-23T15:20:00+02:00</published><updated>2018-10-23T15:20:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2018-10-23:/blog/posts/2018/Oct/23/consul/</id><summary type="html">&lt;p&gt;consul 初体验&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Consul&lt;/h1&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;h3&gt;服务注册与发现&lt;/h3&gt;
&lt;p&gt;&lt;img alt="服务注册与发现方案对比" src="./images/consul-01.png"&gt;&lt;/p&gt;
&lt;h3&gt;Consul&lt;/h3&gt;
&lt;h2&gt;演示&lt;/h2&gt;
&lt;h3&gt;install consul&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$brew install consul&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;verifying the installation&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;$consul&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;run the agent&lt;/h3&gt;
&lt;h4&gt;starting the agent&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;$consul agent -dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为了简单，我们以开发模式启动consul agent。这个模式可以快速和容易的启动一个单节点的consul环境. 这个模式不适合用于生产环境，因为它不保存任何状态。&lt;/p&gt;
&lt;h4&gt;cluster members&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$consul members
Node         Address         Status  Type    Build  Protocol  DC   Segment
avril.local  127.0.0.1:8301  alive   server  1.3.0  2         dc1  &amp;lt;all&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在另一个terminal中执行&lt;code&gt;consul members&lt;/code&gt;，你可以看到consul cluster的members，你可以看到，只有 one member（yourself）.&lt;/p&gt;
&lt;p&gt;输出显示了我们自己的node，这address it is running on，its health state, its role in the cluster, and some version information. 额外的元数据信息可以通过&lt;code&gt;-detailed&lt;/code&gt; flag看到.&lt;/p&gt;
&lt;p&gt;这个命令的输出，基于&lt;code&gt;gossip protocol&lt;/code&gt;, and is 最终一致的。也就是说，在任何节点在同一时间，看到的世界，by 你本地的agent 可能不完全匹配这状态在servers。一个强一致的系统的展示，可以用这&lt;code&gt;HTTP API&lt;/code&gt; 去远程请求consul servers&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$curl localhost:8500/v1/catalog/nodes
[
    {
        &amp;quot;ID&amp;quot;: &amp;quot;9a8b671d-ffdb-6445-f436-9ad02cf7d219&amp;quot;,
        &amp;quot;Node&amp;quot;: &amp;quot;avril.local&amp;quot;,
        &amp;quot;Address&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
        &amp;quot;Datacenter&amp;quot;: &amp;quot;dc1&amp;quot;,
        &amp;quot;TaggedAddresses&amp;quot;: {
            &amp;quot;lan&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
            &amp;quot;wan&amp;quot;: &amp;quot;127.0.0.1&amp;quot;
        },
        &amp;quot;Meta&amp;quot;: {
            &amp;quot;consul-network-segment&amp;quot;: &amp;quot;&amp;quot;
        },
        &amp;quot;CreateIndex&amp;quot;: 9,
        &amp;quot;ModifyIndex&amp;quot;: 10
    }
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于这个HTTP API额外的说一下，&lt;code&gt;DNS interface&lt;/code&gt;可以被用来请求这个节点。提示：你必须确保你的DNS 发现 指向 consul agent's DNS server, which 运行在 8600默认端口上的。这DNS 入口的格式，（类似 "avril.local.node.consul"）可以被发现在一会&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;dig&lt;/span&gt; &lt;span class="mf"&gt;@127.0.0.1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mi"&gt;8600&lt;/span&gt; &lt;span class="n"&gt;avril&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cansul&lt;/span&gt;


&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;DiG&lt;/span&gt; &lt;span class="mf"&gt;9.10.6&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;@127.0.0.1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mi"&gt;8600&lt;/span&gt; &lt;span class="n"&gt;avril&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cansul&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="n"&gt;global&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="n"&gt;Got&lt;/span&gt; &lt;span class="nl"&gt;answer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;HEADER&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;-&lt;/span&gt; &lt;span class="nl"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QUERY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;status&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SERVFAIL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;56796&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="nl"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;qr&lt;/span&gt; &lt;span class="n"&gt;rd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nl"&gt;QUERY&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;ANSWER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;AUTHORITY&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;ADDITIONAL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="nl"&gt;WARNING&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;recursion&lt;/span&gt; &lt;span class="n"&gt;requested&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;available&lt;/span&gt;

&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="n"&gt;QUESTION&lt;/span&gt; &lt;span class="nl"&gt;SECTION&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;avril&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cansul&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;   &lt;span class="n"&gt;IN&lt;/span&gt;  &lt;span class="n"&gt;A&lt;/span&gt;

&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="n"&gt;Query&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;msec&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="nl"&gt;SERVER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;127.0.0.1&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;8600&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;127.0.0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="nl"&gt;WHEN&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Tue&lt;/span&gt; &lt;span class="n"&gt;Oct&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="n"&gt;CST&lt;/span&gt; &lt;span class="mi"&gt;2018&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; &lt;span class="n"&gt;MSG&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;  &lt;span class="nl"&gt;rcvd&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;stopping the agent&lt;/h4&gt;
&lt;p&gt;你可以&lt;code&gt;ctrl-C&lt;/code&gt;去优雅的停止这个agent，当中断这个agent，你可以看到，它离开的cluster，and shut down。&lt;/p&gt;
&lt;p&gt;为了优雅的leaving，consul 通知其他集群成员，这个节点离开了。如果你强行kill这个agent 进程，其他成员将发现这个node fail的。
当一个成员离开，它的服务和检查，将从catalog移除。当一个成员fails，它的健康仅仅标记为critical, 但它不会从catalog中移除。
cansul往往会重连 failed nodes，允许它从好的网络状态下恢复。然而离开的节点永远不会联系。&lt;/p&gt;
&lt;p&gt;另外，如果一个agent 正在操作一个server，一个优雅的离开方式是重要的，去避免造成一些超出控制的影响.&lt;/p&gt;
&lt;h3&gt;services&lt;/h3&gt;
&lt;h4&gt;registering services&lt;/h4&gt;
&lt;p&gt;在前面的步骤里，我们运行了我们的第一个agent，查看了集群的成员，并且访问了这个节点。在本节guide，我们将注册我们第一个service，并且query这个service。&lt;/p&gt;
&lt;h4&gt;defining a service&lt;/h4&gt;
&lt;p&gt;一个服务，可以通过，提供一个服务定义文件，或者调用一个合适的HTTP API&lt;/p&gt;
&lt;p&gt;一个服务定义，是最常用的方式去注册service，所以，我们用这种方式开启下一步。我们将基于上一步的agent 配置。&lt;/p&gt;
&lt;p&gt;首先，创建一个目录用于consul configuration。consul loads 所有的配置文件，in the 配置目录，所以一个通用的形式，在unix系统上是定义这个目录like &lt;code&gt;/etc/consul.d&lt;/code&gt;(the .d suffix implies "this directory contaions a set of configuration files").&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$sudo mkdir /etc/consul.d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们写一个服务定义文件，我们假装我们有一个服务named"web" 跑在80端口，另外，我们给它一个tag，我们可以用来额外的方式查询这个service.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ echo '{"service": {"name": "web", "tags": ["rails"], "port": 80}}' \
    | sudo tee /etc/consul.d/web.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现在，重启agent，提供这个配置目录
&lt;code&gt;$ consul agent -dev -config-dir=/etc/consul.d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你可以注意到他的输出，同步的这个web service。这意味着这个agent加载了这个服务配置，从配置文件里，并且成功注册了他在这服务catalog。&lt;/p&gt;
&lt;p&gt;如果你想去注册multiple services，你可以创建multiple service配置文件在这配置目录里。&lt;/p&gt;
&lt;h4&gt;querying services&lt;/h4&gt;
&lt;p&gt;Once the agent is started and the service is synced, we can query the service using either the DNS or HTTP API.&lt;/p&gt;
&lt;h5&gt;DNS API&lt;/h5&gt;
&lt;p&gt;让我们首先请求我们的服务，用DNS API。for the DNS API, the DNS name for servics is NAME.service.consul. By default, all DNS names are always in the consul namespace, though this is configurable. The service subdomain tells Consul we're querying services, and the NAME is the name of the service.&lt;/p&gt;
&lt;p&gt;For the web service we registered, these conventions and settings yield a fully-qualified domain name of web.service.consul&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ dig &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;127&lt;/span&gt;.0.0.1 -p &lt;span class="m"&gt;8600&lt;/span&gt; web.service.consul
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以看到，一个记录返回了这IP地址，of 这个节点，on which 这个服务存在的。一个记录可以仅仅包含IP地址。&lt;/p&gt;
&lt;p&gt;你可以用这DNS API to retrieve the entrie address/port pair as a SRV record&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;dig&lt;/span&gt; &lt;span class="mf"&gt;@127.0.0.1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mi"&gt;8600&lt;/span&gt; &lt;span class="n"&gt;web&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;consul&lt;/span&gt; &lt;span class="n"&gt;SRV&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个服务记录，说，这个web service 运行在80端口，并且在节点。。上，并且额外的信息返回了，通过这DNS，with the 一个记录 for the node。&lt;/p&gt;
&lt;p&gt;实际上，我们也可以通过DNS API去过滤服务用tags，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;dig&lt;/span&gt; &lt;span class="mf"&gt;@127.0.0.1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mi"&gt;8600&lt;/span&gt; &lt;span class="n"&gt;rails&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;web&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;consul&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;HTTP API&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl http://localhost:8500/v1/catalog/service/web
&lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Node&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;Armons-MacBook-Air&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;Address&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;172.20.20.11&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;ServiceID&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;ServiceName&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;web&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;ServiceTags&amp;quot;&lt;/span&gt;:&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rails&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;ServicePort&amp;quot;&lt;/span&gt;:80&lt;span class="o"&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The catalog API gives all nodes hosting a given service. As we will see later with health checks you'll typically want to query just for healthy instances where the checks are passing. This is what DNS is doing under the hood. Here's a query to look for only healthy instances:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl &lt;span class="s1"&gt;&amp;#39;http://localhost:8500/v1/health/service/web?passing&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Node&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;Armons-MacBook-Air&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;Address&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;172.20.20.11&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;Service&amp;quot;&lt;/span&gt;:&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;ID&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class="s2"&gt;&amp;quot;Service&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class="s2"&gt;&amp;quot;Tags&amp;quot;&lt;/span&gt;:&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;rails&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;Port&amp;quot;&lt;/span&gt;:80&lt;span class="o"&gt;}&lt;/span&gt;, &lt;span class="s2"&gt;&amp;quot;Checks&amp;quot;&lt;/span&gt;: ...&lt;span class="o"&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;updating services&lt;/h4&gt;
&lt;p&gt;服务定义可以被更新，通过改变配置文件，和发送 a SIGHUP to the agent. 这可以让你更新services 没有任何停机或不可用。&lt;/p&gt;
&lt;p&gt;这HTTP API可以被用来，add，remove，modify services dynamically。&lt;/p&gt;
&lt;h3&gt;Connect&lt;/h3&gt;
&lt;h3&gt;Consul Cluster&lt;/h3&gt;
&lt;h3&gt;Health Checks&lt;/h3&gt;
&lt;h3&gt;KV Data&lt;/h3&gt;
&lt;h3&gt;Web UI&lt;/h3&gt;
&lt;h2&gt;todos demo&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/hashicorp/consul&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Website&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://www.consul.io/&lt;/li&gt;
&lt;/ul&gt;</content><category term="consul"></category><category term="micro service"></category></entry></feed>