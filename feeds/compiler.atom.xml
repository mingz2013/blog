<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mingz's Blog - compiler</title><link href="http://mingz.me/blog/" rel="alternate"></link><link href="http://mingz.me/blog/feeds/compiler.atom.xml" rel="self"></link><id>http://mingz.me/blog/</id><updated>2018-10-11T11:30:00+02:00</updated><entry><title>ollvm</title><link href="http://mingz.me/blog/posts/2018/Oct/11/compiler-ollvm/" rel="alternate"></link><published>2018-10-11T11:30:00+02:00</published><updated>2018-10-11T11:30:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2018-10-11:/blog/posts/2018/Oct/11/compiler-ollvm/</id><summary type="html">&lt;p&gt;由解决ios 4.3过审问题引发的探讨&lt;/p&gt;</summary><content type="html">&lt;h1&gt;做的事情&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;之前已经做的东西，资源加密，符号混淆&lt;/li&gt;
&lt;li&gt;本次做的事情，代码膨胀，变形&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;名词介绍&lt;/h1&gt;
&lt;h2&gt;gcc&lt;/h2&gt;
&lt;p&gt;GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。&lt;/p&gt;
&lt;h2&gt;llvm&lt;/h2&gt;
&lt;p&gt;LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。&lt;/p&gt;
&lt;h2&gt;clang&lt;/h2&gt;
&lt;p&gt;Clang是一个C语言、C++、Objective-C语言的轻量级编译器。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。&lt;/p&gt;
&lt;h2&gt;ollvm&lt;/h2&gt;
&lt;p&gt;OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，这个项目的目标是提供一个LLVM编译套件的开源分支，能够通过代码混淆和防篡改，增加对逆向工程的难度，提供更高的软件安全性。目前，OLLVM已经支持LLVM-4.0.1版本。OLLVM的混淆操作就是在中间表示IR层，通过编写Pass来混淆IR，然后后端依据IR来生成的目标代码也就被混淆了。得益于LLVM的设计，OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU,MIPS, MSP430, SystemZ, 和 XCore）&lt;/p&gt;
&lt;h1&gt;llvm相关架构与原理&lt;/h1&gt;
&lt;p&gt;https://llvm.org/docs/&lt;/p&gt;
&lt;p&gt;http://www.aosabook.org/en/llvm.html&lt;/p&gt;
&lt;p&gt;https://llvm.org/docs/WritingAnLLVMPass.html&lt;/p&gt;
&lt;h1&gt;ollvm扩展内容&lt;/h1&gt;
&lt;p&gt;https://github.com/obfuscator-llvm/obfuscator/wiki&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;-fla 控制流扁平化的PASS参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-sub指令替换的PASS参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-bcf虚假控制流的PASS参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;https://blog.csdn.net/chrisnotfound/article/details/79026449&lt;/p&gt;
&lt;h1&gt;demo&lt;/h1&gt;
&lt;p&gt;用Armariris演示编译一个简单的C源码，试用各种参数。&lt;/p&gt;
&lt;p&gt;对编译出的二进制进行分析，查看文件大小，用ida分析二进制，展示流图。&lt;/p&gt;
&lt;h1&gt;攻与防&lt;/h1&gt;
&lt;p&gt;https://bbs.pediy.com/thread-217727.htm&lt;/p&gt;
&lt;p&gt;http://www.freebuf.com/articles/terminal/130142.html&lt;/p&gt;
&lt;h1&gt;github&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/llvm-mirror/llvm"&gt;llvm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/obfuscator-llvm/obfuscator"&gt;ollvm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/HikariObfuscator/Hikari"&gt;Hikari&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/GoSSIP-SJTU/Armariris"&gt;Armariris&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/trailofbits/mcsema"&gt;mcsema&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;参考书籍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《iOS应用逆向与安全》&lt;/li&gt;
&lt;li&gt;《编译与反编译技术实战》&lt;/li&gt;
&lt;li&gt;《LLVM Cookbook中文版》&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;links&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.gnu.org/software/gcc/"&gt;gcc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://clang.llvm.org/"&gt;clang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cnblogs.com/zuopeng/p/4141467.html"&gt;LLVM和GCC的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="compiler"></category><category term="llvm"></category><category term="ollvm"></category></entry><entry><title>编译系统泛讲</title><link href="http://mingz.me/blog/posts/2018/Sep/03/compiler/" rel="alternate"></link><published>2018-09-03T10:30:00+02:00</published><updated>2018-09-03T10:30:00+02:00</updated><author><name>Mingz</name></author><id>tag:mingz.me,2018-09-03:/blog/posts/2018/Sep/03/compiler/</id><summary type="html">&lt;p&gt;泛泛讲解编译系统&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;禁止转载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些图文 出自参考书籍中的截图，如有侵权，请联系删除&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;编程语言的分类&lt;/h1&gt;
&lt;h2&gt;解释型与编译型之分&lt;/h2&gt;
&lt;p&gt;编程语言可分为解释型和编译型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="语言处理器内部的处理过程" src="images/compiler-01.png"&gt;&lt;/p&gt;
&lt;h3&gt;解释型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;源代码转换为某种中间状态，如语法树，语法树直接执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;源代码，词法分析，生成token串，语法分析，生成分析树，语法分析树，或语法树，抽象语法树，执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯粹的解释型，读一句，解释执行一句，执行到有语法错误的时候才会报错&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节码，解释器运行字节码, 也可称为虚拟机
将抽象语法树转换成字节码，字节码可在虚拟机里执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;也有编译的一个过程&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;编译型&lt;/h3&gt;
&lt;h4&gt;编译过程&lt;/h4&gt;
&lt;p&gt;词法分析, 生成token串，语法分析，生成抽象语法树，生成中间代码，生成各个CPU架构的汇编代码，生成各个平台的二进制，&lt;/p&gt;
&lt;p&gt;二进制：真实CPU架构下的二进制，或虚拟机下的二进制（操作码或字节码）&lt;/p&gt;
&lt;p&gt;&lt;img alt="编译器结构" src="images/compiler-04.png"&gt;&lt;/p&gt;
&lt;h4&gt;链接过程&lt;/h4&gt;
&lt;p&gt;链接器，链接成可执行文件&lt;/p&gt;
&lt;h2&gt;动态类型与静态类型之分&lt;/h2&gt;
&lt;h3&gt;动态&lt;/h3&gt;
&lt;h3&gt;静态&lt;/h3&gt;
&lt;h2&gt;强类型与弱类型之分&lt;/h2&gt;
&lt;h3&gt;强类型&lt;/h3&gt;
&lt;h3&gt;弱类型&lt;/h3&gt;
&lt;p&gt;&lt;img alt="编程语言划分" src="images/compiler-17.png"&gt;&lt;/p&gt;
&lt;h1&gt;编译器前端与编译器后端&lt;/h1&gt;
&lt;h2&gt;编译器前端(Front End)&lt;/h2&gt;
&lt;p&gt;从源代码到抽象语法树的过程&lt;/p&gt;
&lt;h2&gt;编译器后端(Back End)&lt;/h2&gt;
&lt;p&gt;从抽象语法树到二进制的过程&lt;/p&gt;
&lt;h1&gt;编程语言的开发方法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;工具型&lt;/li&gt;
&lt;li&gt;手工型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;工具生成&lt;/h2&gt;
&lt;p&gt;用一些工具，定义一些文法，通过工具输入文法，自动生成编译器代码。&lt;/p&gt;
&lt;p&gt;或者 用正则表达式解析源代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;yacc,lex&lt;/li&gt;
&lt;li&gt;Javacc&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;手工构造&lt;/h2&gt;
&lt;p&gt;自顶向下的分析，编写代码&lt;/p&gt;
&lt;h1&gt;编程语言的开发过程&lt;/h1&gt;
&lt;p&gt;首先进行编程语言的设计，然后是词法分析，语法分析，语义分析，生成抽象语法树，生成中间代码，生成操作码，&lt;/p&gt;
&lt;h2&gt;编程语言的设计&lt;/h2&gt;
&lt;p&gt;编程语言的设计，有两种文法表示&lt;/p&gt;
&lt;h3&gt;bnf, ebnf定义文法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BNF（巴科斯范式，Backus Normal Form）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="BNF" src="images/compiler-11.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EBNF(扩展巴克斯范式，Extend BNF)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="BNF" src="images/compiler-12.png"&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="举例" src="images/compiler-10.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="举例2" src="images/compiler-13.png"&gt;&lt;/p&gt;
&lt;h3&gt;地铁图描述文法&lt;/h3&gt;
&lt;p&gt;&lt;img alt="地铁图" src="images/compiler-03.png"&gt;&lt;/p&gt;
&lt;h3&gt;少许理论知识&lt;/h3&gt;
&lt;p&gt;消除左递归（LL（1））&lt;/p&gt;
&lt;p&gt;LL(1)&lt;/p&gt;
&lt;p&gt;LALR(1)&lt;/p&gt;
&lt;p&gt;理解 i++ + ++i 怎么执行的&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;词法分析&lt;/h2&gt;
&lt;p&gt;将源代码分割成若干个记号（token）的过程。&lt;/p&gt;
&lt;p&gt;首先定义token(记号)，用ebnf文法定义词法&lt;/p&gt;
&lt;p&gt;每个token有相应的有限自动机&lt;/p&gt;
&lt;p&gt;顺序读取源代码文件每个字符，用token的有限自动机来选择生成不同的token&lt;/p&gt;
&lt;p&gt;&lt;img alt="有限自动机" src="images/compiler-05.png"&gt;&lt;/p&gt;
&lt;h2&gt;语法分析&lt;/h2&gt;
&lt;p&gt;即从记号构建分析树（parse tree）的过程。分析树也叫作语法树（syntax tree）或抽象语法树（abstract syntax tree，AST）。&lt;/p&gt;
&lt;p&gt;用ebnf定义文法，根据文法写不同的解析代码&lt;/p&gt;
&lt;h2&gt;抽象语法树&lt;/h2&gt;
&lt;p&gt;终结符与非终结符&lt;/p&gt;
&lt;p&gt;可直接编写eval方法，执行每个节点&lt;/p&gt;
&lt;p&gt;&lt;img alt="抽象语法树" src="images/compiler-09.png"&gt;&lt;/p&gt;
&lt;h2&gt;语义分析&lt;/h2&gt;
&lt;p&gt;检查AST中，是否有语义错误，比如不能除0等&lt;/p&gt;
&lt;h2&gt;符号管理&lt;/h2&gt;
&lt;p&gt;需要将各个级别的变量，保存到环境变量中，并标记好级别，
在eval的时候，如果生成变量，就new Var，并记录到环境变量中，
如果计算用到了变量，就从环境变量中取出Var用于计算&lt;/p&gt;
&lt;p&gt;如果推出当前级别的空间，就释放当前级别的空间内的变量,作用域管理&lt;/p&gt;
&lt;h2&gt;生成中间代码&lt;/h2&gt;
&lt;p&gt;符号表，语义分析，中间代码优化等。&lt;/p&gt;
&lt;p&gt;&lt;img alt="中间代码" src="images/compiler-16.png"&gt;&lt;/p&gt;
&lt;h2&gt;生成汇编代码&lt;/h2&gt;
&lt;p&gt;了解不同CPU架构的汇编语言，或自定义虚拟机的汇编语法&lt;/p&gt;
&lt;p&gt;&lt;img alt="Intel x86指令格式" src="images/compiler-15.png"&gt;&lt;/p&gt;
&lt;p&gt;汇编代码优化&lt;/p&gt;
&lt;h2&gt;二进制格式&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ELF文件格式" src="images/compiler-06.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="COFF文件格式" src="images/compiler-14.png"&gt;&lt;/p&gt;
&lt;h2&gt;二进制生成，汇编器&lt;/h2&gt;
&lt;p&gt;了解各个平台的可执行文件结构，格式，编写汇编器，生成二进制&lt;/p&gt;
&lt;p&gt;&lt;img alt="汇编器结构" src="images/compiler-07.png"&gt;&lt;/p&gt;
&lt;h2&gt;可执行文件生成，链接器&lt;/h2&gt;
&lt;p&gt;链接成可执行文件&lt;/p&gt;
&lt;p&gt;&lt;img alt="链接器结构" src="images/compiler-08.png"&gt;&lt;/p&gt;
&lt;h2&gt;错误处理&lt;/h2&gt;
&lt;p&gt;伴随着每个过程，都需要有错误处理，和友好的错误提示&lt;/p&gt;
&lt;h2&gt;优化&lt;/h2&gt;
&lt;p&gt;中间代码优化，汇编代码优化，等，每一部分都有优化部分&lt;/p&gt;
&lt;h1&gt;CPU架构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;intel x86&lt;/li&gt;
&lt;li&gt;ARM&lt;/li&gt;
&lt;li&gt;Power&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h1&gt;虚拟机的设计&lt;/h1&gt;
&lt;p&gt;模拟真实CPU架构&lt;/p&gt;
&lt;p&gt;定义栈空间，定义堆空间，定义寄存器，等数据结构&lt;/p&gt;
&lt;h2&gt;字节码文件的解析&lt;/h2&gt;
&lt;p&gt;读取文件，读取一个个指令，巨大的switch case结构&lt;/p&gt;
&lt;h2&gt;运行时数据区&lt;/h2&gt;
&lt;h3&gt;栈(stack)的设计&lt;/h3&gt;
&lt;h4&gt;栈帧&lt;/h4&gt;
&lt;h3&gt;堆(heap)的设计&lt;/h3&gt;
&lt;h3&gt;局部变量&lt;/h3&gt;
&lt;h3&gt;全局变量&lt;/h3&gt;
&lt;h2&gt;汇编指令与机器码的设计&lt;/h2&gt;
&lt;h2&gt;解释器的设计&lt;/h2&gt;
&lt;h2&gt;GC垃圾回收&lt;/h2&gt;
&lt;h1&gt;JIT&lt;/h1&gt;
&lt;p&gt;java，.NET Framework都具备在运行的同时将字节码转换为机器码的功能，这叫做JIT，Just-In-Time编译技术。&lt;/p&gt;
&lt;h1&gt;编程语言分类漫谈&lt;/h1&gt;
&lt;p&gt;JVM虚拟机，Java，Groovy，Scala，Clojure，Jython，JRuby等。&lt;/p&gt;
&lt;p&gt;CPython&lt;/p&gt;
&lt;p&gt;Pypy&lt;/p&gt;
&lt;p&gt;go&lt;/p&gt;
&lt;p&gt;js&lt;/p&gt;
&lt;h1&gt;编程语言开发示例demo&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/mingz2013/py.calc"&gt;py.calc&lt;/a&gt;解释型语言&lt;/p&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;h2&gt;书籍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Lua设计与实现》&lt;/li&gt;
&lt;li&gt;《Lua 源码欣赏》&lt;/li&gt;
&lt;li&gt;《Go 1.5 源码剖析》&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《Python源码剖析--深度探索动态语言核心技术》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《编译器构造（Java语言版）》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;《自己动手写Java虚拟机》&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《揭秘Java虚拟机-JVM设计原理与实现》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《自制编程语言》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《两周自制脚本语言》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《自制编译器》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;《自己动手构造编译系统 编译、汇编与链接》&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《自己动手写编译器、链接器》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《C编译器剖析》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;《可变目标C编译器：设计与实现》&lt;/li&gt;
&lt;li&gt;《深入分析GCC》&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《高级编译器设计与实现》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《编译系统透视  图解编译原理》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;《编译原理》&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《现代编译原理：c语言描述》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《程序是怎样跑起来的》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;《计算的本质：深入剖析程序和计算机》&lt;/li&gt;
&lt;/ul&gt;</content><category term="compiler"></category><category term="VM"></category></entry></feed>